<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Implicit Normalizing FlowsICLR2021_Spot  Abstract归一化流通过显式可逆变换(explicit invertible transformation) $ \mathbf{z}&#x3D;f(\mathbf{x}) $ 定义概率分布。 在这项工作中，我们提出了隐式归一化流（implicit normalizing flows, ImpFlows），它通过允许由方程">
<meta property="og:type" content="article">
<meta property="og:title" content="G_INF">
<meta property="og:url" content="http://duanyaqi.com/2022/03/28/G-INF/index.html">
<meta property="og:site_name" content="Duan&#39;s Blog">
<meta property="og:description" content="Implicit Normalizing FlowsICLR2021_Spot  Abstract归一化流通过显式可逆变换(explicit invertible transformation) $ \mathbf{z}&#x3D;f(\mathbf{x}) $ 定义概率分布。 在这项工作中，我们提出了隐式归一化流（implicit normalizing flows, ImpFlows），它通过允许由方程">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://duanyaqi.com/2022/03/28/G-INF/assets/1621156780419.png">
<meta property="og:image" content="http://duanyaqi.com/2022/03/28/G-INF/assets/1621156780419.png">
<meta property="og:image" content="http://duanyaqi.com/2022/03/28/G-INF/assets/1621161998415.png">
<meta property="og:image" content="http://duanyaqi.com/2022/03/28/G-INF/assets/1621164873148.png">
<meta property="og:image" content="http://duanyaqi.com/2022/03/28/G-INF/assets/1621164967646.png">
<meta property="og:image" content="http://duanyaqi.com/2022/03/28/G-INF/assets/1621167418876.png">
<meta property="article:published_time" content="2022-03-28T07:59:24.000Z">
<meta property="article:modified_time" content="2022-03-28T08:06:49.768Z">
<meta property="article:author" content="Duan Yaqi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://duanyaqi.com/2022/03/28/G-INF/assets/1621156780419.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://duanyaqi.com/2022/03/28/G-INF/"/>





  <title>G_INF | Duan's Blog</title>
  








<meta name="generator" content="Hexo 6.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a target="_blank" rel="noopener" href="https://github.com/DuanYaQi" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Duan's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">For AI</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://duanyaqi.com/2022/03/28/G-INF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Duan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">G_INF</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-28T15:59:24+08:00">
                2022-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Implicit-Normalizing-Flows"><a href="#Implicit-Normalizing-Flows" class="headerlink" title="Implicit Normalizing Flows"></a>Implicit Normalizing Flows</h1><p>ICLR2021_Spot</p>
<hr>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>归一化流通过<strong>显式可逆变换</strong>(explicit invertible transformation) $ \mathbf{z}=f(\mathbf{x}) $ 定义概率分布。 在这项工作中，我们提出了<strong>隐式归一化流</strong>（implicit normalizing flows, ImpFlows），它通过允许由方程 $ F(\mathbf{z}, \mathbf{x})=0 $ 的根隐式定义映射来<strong>泛化</strong>（generalize）归一化流。 ImpFlows 建立在残差流（ResFlows）上，<strong>在表达性和可处理性之间保持适当的平衡</strong>（a proper balance between expressiveness and tractability）。<br><span id="more"></span></p>
<p>通过理论分析（theoretical analysis），我们发现 ImpFlow 的<strong>函数空间</strong>比 ResFlows 的函数空间<strong>严格丰富</strong>（the function space of ImpFlow is strictly richer than that of ResFlows）。此外，对于具有<strong>固定数量的块</strong>（a fixed number of blocks）的任何ResFlow，存在一些函数使 ResFlow 具有<strong>不可忽略的近似误差</strong>（a non-negligible approximation error）。</p>
<p>但是，该函数可以由单块（single-block） ImpFlow <strong>精确表示</strong>。我们提出了一种<strong>可扩展</strong>（scalable）的算法来<strong>训练</strong>和从 ImpFlows 中<strong>提取样本</strong>。根据经验（Empirically），我们在几个分类和密度建模任务上评估 ImpFlow，并且在所有基准测试中，ImpFlow 的<strong>参数数量</strong>（a comparable amount of parameters）均优于 ResFlow。</p>
<hr>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>标准化流（NFs）（Variational inference with normalizing flows，ICML 2015; Nice，ICLR2014）是用于密度建模的有前途的方法。NFs 通过指定从 $x$ 到另一个随机变量 $z$ 的可逆变换 $f(x)$ 来定义模型分布 $ p_{\mathbf{x}}(\mathbf{x}) $。 通过变量变化(change-of-variable)公式，模型密度为<span id="#eq1"></span></p>
<script type="math/tex; mode=display">
\begin{equation}
 \ln p_{\mathbf{x}}(\mathbf{x})=\ln p_{\mathbf{z}}(f(\mathbf{x}))+\ln \mid \operatorname{det}\left(J_{f}(\mathbf{x})\right) |
\end{equation}\tag{1}</script><p>其中 $ p_{\mathbf{x}}(\mathbf{z}) $ 遵循简单分布，例如高斯分布。NFs 由于其易处理性而特别吸引人，即可以将模型密度 $ p_{\mathbf{x}}(\mathbf{x}) $ 直接评估为 <strong>Eq.1</strong>。为了实现这种可处理性，NFs模型应该满足<strong>两个要求</strong>：（i）$x$ 和 $z$ 之间的映射是可逆的；  （ii）雅可比行列式 $J_{f}(\mathbf{x})$ 的对数行列式是易处理的。寻找满足这些可控性约束 (tractability constraints) 的丰富模型族(rich model families)对于 Nfs 的研究至关重要。对于第二个要求，早期的工作，例如逆自回归流（Kingma，NIPS2016）和RealNVP（Dinh，ICLR2017）将模型族（model family）限制为具有三角形雅可比矩阵的模型族。</p>
<p>最近，出现了一些<strong>自由形式</strong> (free-form) 的 <strong>Jacobian 方法</strong>，例如残差流（ResFlows）（Invertible residual networks，ICML2019; Residual flows for invertible generative modeling，NIPS2019）。他们通过利用<strong>对数行列式</strong>的<strong>随机估计器</strong>（stochastic estimator）来放宽<strong>三角形雅可比约束</strong>，从而<strong>丰富了模型族</strong>。但是，每个<strong>转换块</strong>（transformation block）的Lipschitz <strong>常数</strong>均受<strong>可逆性约束</strong>。通常，这不是可取的，因为将简单的<strong>先验分布</strong>映射到潜在的<strong>复杂数据分布</strong>可能需要具有<strong>非常大</strong>的<strong>Lipschitz常数的转换</strong>（见<strong>Fig. 3</strong>）。此外，所有上述方法（aforementioned methods）都假定存在一个明确的（explicit）前向映射 $ \mathbf{z}=f(\mathbf{x}) $ 。具有显式正向映射的双射仅覆盖了第一个要求所建议的<strong>广义可逆函数的一小部分</strong>（a fraction of the broad class of invertible functions），这可能会限制模型的容量。</p>
<p><img src="assets/1621156780419.png" alt="1621156780419"></p>
<p><strong>Fig. 3:</strong>  Checkerboard data density and the results of a 8-block ResFlow and a 4-block ImpFlow. 棋盘数据密度 以及 8-block ResFlow 和 4-block ImpFlow的结果。</p>
<p>在本文中，我们提出了 implicit flows（ImpFlows）来<strong>泛化</strong>NFs，<strong>允许转换被</strong> $ F(\mathbf{z}, \mathbf{x})=0 $ <strong>隐式定义</strong>。给定 $x$（或$z$），可以通过隐式的根查找过程（root-finding procedure） $ \mathbf{z}=\operatorname{RootFind}(F(\cdot, \mathbf{x})) $ 来计算另一个变量。可以将先前 NFs 中使用的显式映射 $z = f(x)$ 视为 <strong>ImpFlow 的特殊情况</strong>，形式为 $F(z，x)= f(x)− z =0$. </p>
<p>为了在<strong>表达性和可处理性</strong>之间取得平衡，我们从 ImpFlows 中提出了一个特殊的定义，其中每个 block 是由 <strong>ResFlow block 和另一个ResFlow block的逆</strong>来组成。我们从理论上研究<strong>函数空间中</strong> ResFlows 和 ImpFlows 的<strong>模型容量</strong>。 通过<strong>放宽 Lipschitz 约束</strong>，我们证明了 single-block ImpFlow 的<strong>函数族</strong>比 two-block ResFlow的函数族<strong>严格丰富</strong>。此外，对于任何具有固定块数的ResFlow，都存在某些可逆函数，使 ResFlow 具有<strong>不可忽略的近似误差</strong>，但是ImpFlow可以精确建模。</p>
<p>在实践方面，我们开发了一种<strong>可伸缩</strong>的（scalable）算法来估计概率密度及其梯度，并从ImpFlows中提取样本。 该算法利用（leverages）<strong>隐式微分公式</strong>（implicit differentiation formula）。尽管功能更强大，但是ImpFlow的梯度计算与 ResFlows 的梯度计算大部分相似，除了在<strong>根查找方面有一些额外的开销</strong>。我们在几个分类和生成建模任务上测试了 ImpFlow 的有效性。ImpFlow 在所有基准测试上均优于 ResFlow，具有可比的模型大小和计算成本。（comparable model sizes and computational cost）</p>
<hr>
<h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><h3 id="2-1-Expressive-Normalizing-Flows"><a href="#2-1-Expressive-Normalizing-Flows" class="headerlink" title="2.1. Expressive Normalizing Flows"></a>2.1. Expressive Normalizing Flows</h3><p>有许多工作致力于提高NFs的能力。例如，Dinh等（ICLR2014, Nice; ICLR2017, RealNVP）; Kingma &amp; Dhariwal（NIPS2018, Glow）;  Ho等（ICML2019, Flow++: Improving flow-based generative models with variational dequantization and architecture design）; 宋等（NIPS2019, Mintnet: Building invertible neural networks with masked convolutions）;  Hoogeboom等（ICML2019, Emerging convolutions for generative<br>normalizing flows）;  De Cao等（UAI2020, Block neural autoregressive flow）；  Durkan等（NIPS2019,  Neural spline flows）用<strong>易处理的Jacobian</strong>设计<strong>专用的模型架构</strong>。 </p>
<p>最近，Grathwohl等（ICLR2019, <strong>Ffjord</strong>:Free-form continuous dynamics for scalable reversible generative models）;  Behrmann等 （ICML2019, <strong>Invertible residual networks</strong>）;  Chen等（NIPS2019,<strong>Residual flows for invertible generative modeling</strong>）提出了具有<strong>自由形式雅可比行列式</strong>(不限制三角矩阵)的NFs，它们用<strong>随机估计量近似了行列式</strong>。 </p>
<p>在架构设计的同时，Chen等（ICML2020, <strong>Vflow</strong>: More expressive generative flows with variational data augmentation）； Huang等（arXiv2020,  <strong>Augmented normalizing flows</strong>: Bridging the gap between generative flows and latent variable models）； Cornish等（ICML2020,  <strong>Relaxing bijectivity constraints</strong> with continuously indexed normalising flows）；  Nielsen等（arXiv2020, <strong>Survae flows</strong>: Surjections to bridge the gap between vaes and flows）通过在<strong>更高维度的空间中操作</strong>来提高NFs的能力。</p>
<p>正如引言中提到的，所有这些现有作品都采用<strong>显式正向映射</strong>，这仅是广泛的<strong>可逆函数类的子集</strong>。相反，我们认为的<strong>隐式函数族更丰富</strong>。 虽然我们在本文中主要讨论 ResFlows 的<strong>隐式泛化</strong>（Chen, NIPS2019, <strong>Residual flows for invertible generative modeling</strong>），但利用隐式可逆函数的一般思想也可能会应用于其他模型。 最后，张等（ICML2020, Approximation capabilities of neural odes and invertible residual networks）正式证明 ResFlows 的<strong>模型能力受到残差块尺寸的限制</strong>。相比之下，我们根据<strong>有界 Lipschitz 常数</strong>研究 ResFlows 的另一个局限性，并以可比较的深度比较 ResFlows 和 ImpFlows 的<strong>函数族</strong>。</p>
<hr>
<h3 id="2-2-Continuous-Time-Flows-CTFs"><a href="#2-2-Continuous-Time-Flows-CTFs" class="headerlink" title="2.2. Continuous Time Flows (CTFs)"></a>2.2. Continuous Time Flows (CTFs)</h3><p>（Chen，NIPS2018b; Grathwohl，ICLR2019; Chen，ICML2018a）是用于生成模型的<strong>离散时间流</strong>的灵活替代方案。 他们通常将<strong>可逆变换</strong>视为一个<strong>动力系统</strong>，该动力系统由<strong>常微分方程</strong>（ODE）<strong>求解器近似模拟</strong>。相反，本文考虑的隐式函数族<strong>不包含微分方程</strong>，仅需要<strong>定点解算器</strong>(fixed point solvers)。而且，理论上的保证是不同的。 尽管 CTFs 通常研究<strong>连续时间</strong>（即“无限深度”限制）情况下的<strong>通用逼近能力</strong>（universal approximation），但我们在<strong>有限数量的转换步骤</strong>（a finite number of transformation steps）下考虑了 ImpFlows 和 ResFlows 的模型能力。最后，尽管CTFs 很灵活，但由于<strong>不稳定性</strong>（Liu，CVPR2020; Massaroli，arXiv2020）和<strong>过多的ODE求解器步骤</strong>（Finlay，ICML2020），它们的学习具有挑战性，使其<strong>大规模应用</strong>仍然是一个未解决的问题。</p>
<hr>
<h3 id="2-3-Implicit-Deep-Learning"><a href="#2-3-Implicit-Deep-Learning" class="headerlink" title="2.3. Implicit Deep Learning"></a>2.3. Implicit Deep Learning</h3><p>利用<strong>隐式函数可增强神经网络的灵活性</strong>，从而以<strong>特定于问题的方式进行网络层的设计</strong>(problem-specific way)。 例如，Bai（NIPS2019）提出了一种深度均衡(equilibrium)模型，作为递归网络的紧凑替代;  Amos＆Kolter（ICML2017,  Differentiable optimization as a layer in neural networks.）<strong>泛化了每一层以解决优化问题</strong>；Wang（ICML2019）将<strong>逻辑推理整合到神经网络中</strong>;  Reshniak＆Webster（2019）利用<strong>隐式Euler</strong>方法来提高<strong>残差块正向和反向过程的稳定性</strong>; Sitzmann（2020）引入<strong>周期函数</strong>以进行表征学习。<strong>与这些将隐式函数替换为前馈网络的工作不同</strong>，我们为 NFs 开发了的<strong>可逆的隐式函数</strong>，讨论了此类函数存在的条件，并从理论上研究了我们提出的 ImpFlow 在该函数空间中的模型的能力。</p>
<hr>
<h2 id="3-Implicit-Normalizing-Flows"><a href="#3-Implicit-Normalizing-Flows" class="headerlink" title="3. Implicit Normalizing Flows"></a>3. Implicit Normalizing Flows</h2><p>现在，我们将从对现有工作的简要概述开始(by starting with a brief overview of existing work)，介绍隐式规范化流程。</p>
<hr>
<h3 id="3-1-Normalizing-Flows"><a href="#3-1-Normalizing-Flows" class="headerlink" title="3.1. Normalizing Flows"></a>3.1. Normalizing Flows</h3><p>如 <a href="#eq1">Eq. 1</a> 所示，标准化流 $ f: \mathbf{x} \mapsto \mathbf{z} $ 是一个可逆函数，它使用变量变化公式（change-of-variable formula）定义概率分布。标准化流的建模能力取决于可逆函数 $f$ 的表达。Residual flows （ResFlows）（Chen，2019; Behrmann，2019）由于其<strong>自由形式</strong> (free-form) 的 <strong>Jacobian 形式</strong>而成为一类特别强大的NFs。ResFlows 使用 $ f=f_{L} \circ \cdots \circ f_{1} $ 来构造<strong>可逆映射</strong>，其中每一层 $f_l$ 是具有 <strong>Lipschitz约束</strong> 并由固定常数 $κ$ 限制的可逆残差网络： </p>
<script type="math/tex; mode=display">
\begin{equation}
 f_{l}(\mathbf{x})=\mathbf{x}+g_{l}(\mathbf{x}), \quad \operatorname{Lip}\left(g_{l}\right) \leq \kappa<1 
\end{equation}\tag{2}</script><p>其中 $\operatorname{Lip}\left(g\right)$ 是函数 $g$ 的 Lipschitz常数（详细信息见 <a href="#sec41">Sec. 4.1</a>）。尽管有 free-form 的Jacobian，ResFlows的模型<strong>能力仍受可逆函数的 Lipschitz 常数限制</strong>。每个ResFlow block $f_l$ 的 <strong>Lipschitz 常数不能超过2</strong>（Behrmann，2019），因此 <strong>L-block 的 ResFlow的 Lipschitz 常数不能超过</strong> $2^L$。但是，为了将简单的<strong>先验分布转换为潜在的复杂数据分布</strong>，通常<strong>要求转换的Lipschitz常数足够大</strong>。因此，仅仅<strong>满足Lipschitz约束</strong>，<strong>ResFlows可能会很深</strong>（见 <strong>Fig. 3</strong>）。下面，我们介绍隐式流（ImpFlows）以<strong>放松Lipschitz约束</strong>。</p>
<p><img src="assets/1621156780419.png" alt="1621156780419"></p>
<p><strong>Fig. 3:</strong>  Checkerboard data density and the results of a 8-block ResFlow and a 4-block ImpFlow. 棋盘数据密度 以及 8-block ResFlow 和 4-block ImpFlow的结果。</p>
<hr>
<h3 id="3-2-Model-Specification"><a href="#3-2-Model-Specification" class="headerlink" title="3.2. Model Specification"></a>3.2. Model Specification</h3><p>通常，将隐式流（ImpFlow）定义为 $d$ 维随机变量 $\mathbf{x}$ 和 $\mathbf{z}$ 之间的可逆映射，并通过找到 $ F(\mathbf{z}, \mathbf{x})=\mathbf{0} $ 的根，其中 $F$ 是从 $\mathbb{R}^{2d}$ 到 <script type="math/tex">\mathbb{R}^{d}</script> 的函数。特别的，先前 flow 实例中使用的显式映射 $ \mathbf{z}=f(\mathbf{x}) $（Chen，2019; Kingma＆Dhariwal，2018）可以表示为隐式函数，形式为 $\begin{equation}<br> F(\mathbf{z}, \mathbf{x})=f(\mathbf{x})-\mathbf{z}=\mathbf{0}<br>\end{equation}$。虽然 ImpFlows 是一个强大的族，但通常不能保证它们满足 NFs 所要求的<strong>对数行列式的可逆性</strong>和<strong>易处理性</strong>。在本文中，我们将重点放在以下特定形式上，该形式在<strong>表达性和可延展性</strong>之间取得了良好的平衡，并为以后的研究留下了其他可能性。</p>
<h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition 1."></a>Definition 1.<span id="#def1"></span></h4><p>令 $ g_{\mathbf{z}}: \mathbb{R}^{d} \rightarrow \mathbb{R}^{d} $ 和 $ g_{\mathbf{x}}: \mathbb{R}^{d} \rightarrow \mathbb{R}^{d} $  是两个函数，使得 $ \operatorname{Lip}\left(g_{\mathbf{x}}\right)<1 $ 和 $ \operatorname{Lip}\left(g_{\mathbf{z}}\right)<1 $，其中 $ \operatorname{Lip}\left(g\right) $ 是函数 $g$ 的Lipschitz 常数。ImpFlows 的**特定形式**定义为<span id="eq3">&lt;/span&gt;</p>
<script type="math/tex; mode=display">
\begin{equation}
 F(\mathbf{z}, \mathbf{x})=\mathbf{0},  \quad\text{where}  \quad F(\mathbf{z}, \mathbf{x})=g_{\mathbf{x}}(\mathbf{x})-g_{\mathbf{z}}(\mathbf{z})+\mathbf{x}-\mathbf{z} 
\end{equation} \tag{3}</script><p><a href="#eq3">Eq. 3</a> 的根组解在 $\mathbb{R}^{d} \times \mathbb{R}^{d}$中形成一个子集，它实际上定义了唯一可逆函数 $f$ 的赋值规则(assignment rule)。</p>
<p>对于任何的 $\mathbf{x}_0$，根据 <a href="#def1">Definition 1</a>，我们可以构造一个收缩 $ h_{\mathbf{x}_{0}}(\mathbf{z})=F\left(\mathbf{z}, \mathbf{x}_{0}\right)+\mathbf{z} $, 它具有唯一的固定点，对应于唯一的根（关于 $\mathbf{z}$ ）  $ F\left(\mathbf{z}, \mathbf{x}_{0}\right)=\mathbf{0} $，由 $ f\left(\mathbf{x}_{0}\right) $ 表示。 </p>
<p>类似地，在反向过程中，给定 $\mathbf{z}_{0}$，$ F\left(\mathbf{z}_{0}, \mathbf{x}\right)=\mathbf{0} $ 的根（关于 $\mathbf{x}$）也存在并且是唯一的，用 $ f^{-1}\left(\mathbf{z}_{0}\right) $ 表示。 如 <a href="#the1">Theorem 1</a> 总结，这两个属性足以确保 $f$ 的存在和可逆。 </p>
<h4 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem 1. "></a>Theorem 1. <span id="#the1"></span></h4><p><a href="#eq3">Eq. 3</a> 定义了一个唯一的映射 $ f: \mathbb{R}^{d} \rightarrow \mathbb{R}^{d}, \mathbf{z}=f(\mathbf{x}) $，并且 $f$ 是可逆的。</p>
<p>见 <a href="#app1">Appendix A.1</a> 中的证明。<a href="#the1">Theorem 1</a> 表征了（characterizes） <a href="#def1">Definition 1</a> 中引入的 ImpFlow 的有效性（the validness of）。实际上，a single ImpFlow 是 a single ResFlow 和另一个 single ResFlow的逆 的<strong>堆栈</strong>，这将在 <strong>Sec. 4</strong> 中正式说明。我们将在 <strong>Sec. 4</strong> 中研究ImpFlows的函数族的表达性，并在 <strong>Sec. 5</strong> 提出一种可扩展的算法来学习基于 <strong>Sec 4</strong> 中的 ImpFlows 的<strong>深度生成模型</strong>。  </p>
<hr>
<h2 id="4-Expressiveness-Power"><a href="#4-Expressiveness-Power" class="headerlink" title="4. Expressiveness Power"></a>4. Expressiveness Power</h2><p>我们首先在 <a href="#sec41">Sec. 4.1</a> 介绍一些关于 <strong>Lipschitz 连续函数</strong>的初步知识。 然后正式研究 ImpFlows 的表达能力，尤其是与 ResFlows 相比。特别的，我们在 <a href="#sec42">Sec. 4.2</a> 证明了 ImpFlows 的函数空间比的 ResFlows 的函数空间严格丰富，见 <strong>Fig. 1(a)</strong>。 此外，对于具有固定数量的块的任何ResFlow，存在一些函数，使 ResFlow 具有不可忽略的近似误差。 但是，该函数可以由 single-block ImpFlow精确表示。 结果显示在 <strong>Fig. 1(b)</strong> 中，并在 <a href="#sec43">Sec. 4.3</a> 中正式提出。</p>
<p><img src="assets/1621161998415.png" alt="1621161998415"></p>
<p><strong>Fig. 1:</strong> An illustration of our main theoretical results on the expressiveness power of ImpFlows and ResFlows. Panel (a) and Panel (b) correspond to results in Sec. 4.2 and Sec. 4.3 respectively.</p>
<hr>
<h3 id="4-1-Lipschitz-Continuous-Functions"><a href="#4-1-Lipschitz-Continuous-Functions" class="headerlink" title="4.1. Lipschitz Continuous Functions"></a>4.1. Lipschitz Continuous Functions<span id="sec41"></span></h3><p>对于任何可微函数 $ f: \mathbb{R}^{d} \rightarrow \mathbb{R}^{d} $ 和任何 $ \mathbf{x} \in \mathbb{R}^{d} $，我们将 $f$ 在 $\mathbf{x}$ 处的雅可比矩阵表示为 $ J_{f}(\mathbf{x}) \in \mathbb{R}^{d \times d} $</p>
<h4 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition 2."></a>Definition 2.</h4><p>如果存在常数 $L$ 满足下式，则函数 $ \mathbb{R}^{d} \rightarrow \mathbb{R}^{d} $ 称为Lipschitz连续。</p>
<script type="math/tex; mode=display">
\begin{equation}
 \left\|f\left(\mathbf{x}_{1}\right)-f\left(\mathbf{x}_{2}\right)\right\| \leq L\left\|\mathbf{x}_{1}-\mathbf{x}_{2}\right\|, \forall \mathbf{x}_{1}, \mathbf{x}_{2} \in \mathbb{R}^{d} 
\end{equation}</script><p>满足不等式 (inequality) 的最小 $L$ 称为 $f$ 的 Lipschitz常数，表示为 $ \operatorname{Lip}(f) $。</p>
<p>通常， $ \operatorname{Lip}(f) $ 的定义取决于 <script type="math/tex">|| ·||</script>的选择，为简单起见，本文默认使用L2-范数。</p>
<hr>
<h4 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition 3."></a>Definition 3.</h4><p>如果函数 $ f: \mathbb{R}^{d} \rightarrow \mathbb{R}^{d} $ 是 Lipschitz 连续的并且具有逆映射 $f^{-1}$（且逆映射也是Lipschitz连续），则称函数 $f$ 为 bi-Lipschitz 连续。</p>
<p>在下面的分析中考虑 Lipschitz 常数的等效定义是很有用的。</p>
<hr>
<h4 id="Proposition-1"><a href="#Proposition-1" class="headerlink" title="Proposition 1."></a>Proposition 1.</h4><p>命题1</p>
<p>Rademacher（Federer（1969），Theorem 3.1.6）</p>
<p>如果 $ f: \mathbb{R}^{d} \rightarrow \mathbb{R}^{d} $ 是 Lipschitz 连续的，则 $f$ 几乎在任何地方都是可微的，并且</p>
<script type="math/tex; mode=display">
\begin{equation}
 \operatorname{Lip}(f)=\sup _{\mathbf{x} \in \mathbb{R}^{d}}\left\|J_{f}(\mathbf{x})\right\|_{2} 
\end{equation}</script><p>其中 $ |M|_{2}=\sup _{\left\{\mathbf{v}:|\mathbf{v}|_{2}=1\right\}} |M \mathbf{v}|_{2}  $ 是矩阵 $ M \in \mathbb{R}^{d \times d} $ 的算子范数</p>
<hr>
<h3 id="4-2-Comparision-to-Two-Block-ResFlows"><a href="#4-2-Comparision-to-Two-Block-ResFlows" class="headerlink" title="4.2. Comparision to Two-Block ResFlows"></a>4.2. Comparision to Two-Block ResFlows<span id="sec42"></span></h3><p><img src="assets/1621164873148.png" alt="1621164873148"></p>
<p><strong>Fig. 1a:</strong> Relationship between $\mathcal{R}_2$ and $\mathcal{I}$.</p>
<p><img src="assets/1621164967646.png" alt="1621164967646"></p>
<p><strong>Fig. 2:</strong>  A 1-D motivating example. 一维激励的例子。（a）目标函数图。（b）使用具有不同块数的ResFlows拟合目标函数的结果。由于Lipschtiz约束，所有函数都有不可忽略的（non-negligible）逼近误差。（c）可以精确表示目标函数的 ImpFlow。（d）合成 <strong>ResFlow block</strong> 和<strong>另一个 ResFlow block 的逆</strong>以构造ImpFlow block 的可视化视图。 详细设置可以在 <a href="#appd">Appendix D</a> 中找到。</p>
<p>我们正式比较了 a single-block ImpFlow 和 a two-block ResFlow 的表达能力。我们在 <strong>Fig. 1a</strong> 的这一小节中突出了理论结果的结构，并在 <strong>Fig. 2</strong> 中给出了一个一维激活的例子。所有的证明都可以在 <a href="#appa">Appendix. A</a> 中找到。 另一方面，根据 ResFlow 的定义，single-block ResFlow 的函数族为 <span id="eq4"></span></p>
<script type="math/tex; mode=display">
\begin{equation}
 \mathcal{R}:=\left\{f: f=g+\mathrm{Id}, g \in C^{1}\left(\mathbb{R}^{d}, \mathbb{R}^{d}\right), \operatorname{Lip}(g)<1\right\} 
\end{equation}\tag{4}</script><p>其中 $ C^{1}\left(\mathbb{R}^{d}, \mathbb{R}^{d}\right) $ 包含从 $ \mathbb{R}^{d} $ 到 $ \mathbb{R}^{d} $ 的所有具有连续导数的函数，$\mathrm{Id}$ 表示恒等图。 此外，$\ell$-block ResFlows 的函数族由以下组成定义： <span id="eq5"></span></p>
<script type="math/tex; mode=display">
\begin{equation}
 \mathcal{R}_{\ell}:=\left\{f: f=f_{\ell} \circ \cdots \circ f_{1}\right. \text{for some } \left.f_{1}, \cdots, f_{\ell} \in \mathcal{R}\right\} 
\end{equation}\tag{5}</script><p>根据 <a href="#eq4">Eq. 4</a> 和 <a href="#eq5">Eq. 5</a>，$ \mathcal{R}_{1}=\mathcal{R} $。</p>
<p>另一方面，根据 <a href="#eq3">Eq. 3</a> 中 ImpFlow 的定义，我们可以获得 $(g_{\mathbf{x}} + \mathrm{Id})(\mathbf{x})=g_{\mathbf{x}}(\mathbf{x})+\mathbf{x}=g_{\mathbf{z}} (\mathbf{z})+\mathbf{z}=\left(g_{\mathbf{z}}+\mathrm{Id}\right)(\mathbf{z}) $，其中 $◦$ 表示函数的组成。同理，我们有 $ \mathbf{z}=\left(\left(g_{\mathbf{z}}+\mathrm{Id}\right)^{-1} \circ\left(g_{\mathbf{x}}+\mathrm{Id}\right)\right)(\mathbf{x}) $ ，这意味着 single-block ImpFlow 的函数族是 </p>
<script type="math/tex; mode=display">
\begin{equation}
 \mathcal{I}=\left\{f: f=f_{2}^{-1} \circ f_{1}\right. \text{for some } \left.f_{1}, f_{2} \in \mathcal{R}\right\} 
\end{equation}\tag{6}</script><p>直观上，a single-block ImpFlow 可以解释为 <strong>一个 ResFlow block 和另一个ResFlow block 的逆函数</strong>的组成，它们可能没有明确的形 explicit form（有关1D示例，见 <strong>Fig. 2c</strong> 和 <strong>Fig. 2d</strong> ）。因此，研究  $\mathcal{I}$ 和 $\mathcal{R}_2$ 之间的关系是很自然的。</p>
<p>在此之前，我们首先介绍一个没有明显 Lipschitz 约束的“单调递增函数”族（monotonically increasing functions），并证明它严格大于 $\mathcal{R}$ 。</p>
<h4 id="Lemma-1"><a href="#Lemma-1" class="headerlink" title="Lemma 1."></a>Lemma 1.<span id="le1"></span></h4><p>引理1</p>
<script type="math/tex; mode=display">
\begin{equation}
 \mathcal{R} \varsubsetneqq \mathcal{F}:=\left\{f \in \mathcal{D}: \underset{\mathbf{x} \in \mathbb{R}^{d}, \mathbf{v} \in \mathbb{R}^{d},\|\mathbf{v}\|_{2}=1}{ \operatorname{inf}} \mathbf{v}^{T} J_{f}(\mathbf{x}) \mathbf{v}>0\right\} 
\end{equation}</script><p>其中 $\mathcal{D}$ 是从 $ \mathbb{R}^{d} $ 到 $ \mathbb{R}^{d} $ 的所有 bi-Lipschitz $C^1$-diffeomorphisms(同态)的集合，而 $ A \varsubsetneqq B $ 表示 $A$ 是 $B$ 的真子集（proper subset）。</p>
<p>请注意，它遵循 Behrmann（2019，Lemma2），所有在 $ \mathcal{R} $ 中的函数都是 bi-Lipschitz 的，所以 $ \mathcal{R} \varsubsetneqq \mathcal{D} $ . 在1D 输入情况下，我们可以得到 $ \mathcal{R}=\left\{f \in C^{1}(\mathbb{R}): \inf _{x \in \mathbb{R}} f^{\prime}(x)&gt;0, \sup _{x \in \mathbb{R}} f^{\prime}(x)<2\right\} $，并且 $ \mathcal{F}=\left\{f \in C^{1}(\mathbb{R}): \inf _{x \in \mathbb{R}} f^{\prime}(x)>0\right\} $。在高维情况下，$\mathcal{R}$ 和 $\mathcal{F}$ 难以阐述。尽管如此，$\mathcal{R}$ 中函数的 Lipschitz 常数小于 2（Behrmann，2019），但 $\mathcal{F}$ 中函数的 Lipschitz 常数可以任意大。</p>
<p>基于 <a href="le1">Lemma 1</a>，我们证明ImpFlows $ \mathcal{I} $ 的函数族由 $\mathcal{F}$ 中两个函数的组成组成，因此严格大于 $ \mathcal{R}_2 $ ，如以下定理所总结。</p>
<h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem 2."></a>Theorem 2.</h4><p>a single-block ImpFlow的函数族的等效形式（Equivalent form）。</p>
<script type="math/tex; mode=display">
\begin{equation}
 \mathcal{I}=\mathcal{F}_{2}:=\left\{f: f=f_{2} \circ f_{1}\right. \text{for some } \left.f_{1}, f_{2} \in \mathcal{F}\right\} 
\end{equation}</script><p>注意，恒等映射 $ I d \in \mathcal{F} $，很容易得到 $ \mathcal{F} \subset \mathcal{I} $。因此，a single ImpFlow 的 Lipschitz 常数（及其逆）可以任意（arbitrarily）大。 由于 $ \mathcal{R} \varsubsetneqq \mathcal{F} $ ，并且 $ \mathcal{I} \backslash \mathcal{R}_{2} $ 中存在一些函数（参见 <a href="#sec43">Sec 4.3</a> 中的构造示例），因此可以得出以下推论。</p>
<h4 id="Corollary-1"><a href="#Corollary-1" class="headerlink" title="Corollary 1."></a>Corollary 1.<span id="cor1"></span></h4><script type="math/tex; mode=display">
 \mathcal{R} \varsubsetneqq \mathcal{R}_{2} \varsubsetneqq \mathcal{F}_{2}=\mathcal{I}</script><p><strong>Fig. 2b and 2c</strong> 中一维示例的结果与 <a href="#cor1">Corollary 1</a>一致。此外， <a href="#cor1">Corollary 1</a> 可以推广到具有 $2\ell$-block ResFlows 和 $\ell$-block ImpFlows的情况，这强烈地推动了normalizing flows中的隐式层的使用。</p>
<hr>
<h3 id="4-3-Comparison-with-Multi-Block-ResFlows"><a href="#4-3-Comparison-with-Multi-Block-ResFlows" class="headerlink" title="4.3. Comparison with Multi-Block ResFlows"></a>4.3. Comparison with Multi-Block ResFlows<span id="sec43"></span></h3><p><img src="assets/1621167418876.png" alt="1621167418876"></p>
<p><strong>Fig. 1b</strong>  Relationship between $ \mathcal{R}_{0} $ and $ \mathcal{I} $</p>
<p>如 <strong>Fig. 1b</strong> 所示，我们进一步研究了 $ \mathcal{R}_{\ell} $ ($\ell&gt;2$)和 <script type="math/tex">\mathcal{I}</script> 之间的关系。对于固定的 $\ell$，$ \mathcal{R}_{\ell} $ 中函数的 Lipschitz 常数仍然是有界的，并且有无限个不存在于 $ \mathcal{R}_{\ell} $ 中但在 <script type="math/tex">\mathcal{I}</script> 中的函数。我们构造了一个这样的函数族：对于任何$ L, r \in \mathbb{R}^{+} $，定义</p>
<script type="math/tex; mode=display">
\begin{equation}
 \mathcal{P}(L, r)=\left\{f: f \in \mathcal{F}, \exists \mathcal{B}_{r} \subset \mathbb{R}^{d}, \forall \mathbf{x}, \mathbf{y} \in \mathcal{B}_{r},\|f(\mathbf{x})-f(\mathbf{y})\|_{2} \geq L\|\mathbf{x}-\mathbf{y}\|_{2}\right\} 
\end{equation}\tag{9}</script><p>其中 $\mathcal{B}_{r}$ 是半径为 $r$ 的 $d$ 维球。显然，$\mathcal{P}(L, r)$ 是一个无限集。下面，我们将展示 $ \forall 0&lt;\ell&lt;\log _{2}(L)$，$\mathcal{R}_{\ell} $ 对于$\mathcal{P}(L, r)$ 中的函数具有不可忽略的近似误差。 但是，它们完全可以由 <script type="math/tex">\mathcal{I}</script> 中的函数表示。</p>
<h4 id="Theorem-3"><a href="#Theorem-3" class="headerlink" title="Theorem 3."></a>Theorem 3.<span id="the3"></span></h4><p>给定 $ L&gt;0 $ 和 $ r&gt;0 $，我们有</p>
<ul>
<li><p>$ \mathcal{P}(L, r) \subset \mathcal{I} $</p>
</li>
<li><p>$ \forall 0&lt;\ell&lt;\log _{2}(L),  \mathcal{P}(L, r) \cap \mathcal{R}_{\ell}=\varnothing  $. 此外，对于任何具有 $d$ 维球 $\mathcal{B}_{r}$ 的 $ f \in \mathcal{P}(L, r) $，用 $ \mathcal{R}_{\ell} $ 函数拟合 $\mathcal{B}_{r}$ 中的 $f$ 的最小误差满足</p>
<script type="math/tex; mode=display">
\begin{equation}
 \inf _{g\in \mathcal{R}_{\ell}} \sup _{\mathbf{x} \in \mathcal{B}_{r}}\|f(\mathbf{x})-g(\mathbf{x})\|_{2} \geq \frac{r}{2}\left(L-2^{\ell}\right) 
\end{equation}\tag{10}</script></li>
</ul>
<p>遵循 <a href="#the3">Theorem 3</a>，要建模 $ f \in \mathcal{P}(L, r) $，我们只需要 a single-block ImpFlow，但至少需要a -$ \log _{2}(L) $-block  ResFlow。在 <strong>Fig. 2b</strong> 中，我们展示了 1D 情况，其中a 3-block ResFlow 无法拟合 a single ImpFlow 可以精确表示的函数。此外，我们还证明了 ImpFlows 的其他一些属性。特别是 $ \mathcal{R}_{3} \not \subset \mathcal{I} $。我们将结果正式呈现在 <a href="#appb">Appendix B</a> 中。</p>
<hr>
<h2 id="5-Generative-Modeling-With-ImpFlows"><a href="#5-Generative-Modeling-With-ImpFlows" class="headerlink" title="5. Generative Modeling With ImpFlows"></a>5. Generative Modeling With ImpFlows</h2><p>ImpFlows can be parameterized by neural networks and stacked to form a deep generative model to<br>model high-dimensional data distributions. We develop a scalable algorithm to perform inference,<br>sampling and learning in such models. For simplicity, we focus on a single-block during derivation.<br>Formally, a parametric ImpFlow block z = f(x;θ) is defined by</p>
<p>可以通过神经网络对ImpFlows进行参数化，然后将其堆叠以形成一个深度生成模型，以对高维数据分布进行建模。 我们开发了一种可扩展的算法，可以在此类模型中执行推理，采样和学习。 为简单起见，我们将重点放在推导过程中的单个块上。<br>   形式上，参数ImpFlow块z = f（x;θ）定义为</p>
<p>and Lip(g x ) &lt; 1, Lip(g z ) &lt; 1. Let θ denote all the parameters in g x and g z (which does NOT mean<br>g x and g z share parameters). Note that x refers to the input of the layer, not the input data.<br>The inference process to compute z given x in a single ImpFlow block is solved by finding the root<br>of F(z,x;θ) = 0 w.r.t. z, which cannot be explicitly computed because of the implicit formulation.<br>Instead, we adopt a quasi-Newton method (i.e. Broyden’s method (Broyden, 1965)) to solve this<br>problem iteratively, as follows:</p>
<p>和Lip（g x）&lt;1，Lip（g z）&lt;1。令θ表示g x和g z中的所有参数（这并不意味着g x和g z共享参数）。 请注意，x是指图层的输入，而不是输入数据。<br> 通过找到F（z，x;θ）= 0 w.r.t的根来求解在给定x的单个ImpFlow块中计算z的推理过程。  z，由于隐式公式而无法显式计算。<br>   相反，我们采用拟牛顿法（即Broyden法（Broyden，1965年））来迭代地解决此问题，如下所示： </p>
<p>where B is a low-rank approximation of the Jacobian inverse 1 and α is the step size which we use<br>line search method to dynamically compute. The stop criterion is kF(z [i] ,x;θ)k 2 &lt; ? f , where ? f<br>is a hyperparameter that balances the computation time and precision. As Theorem 1 guarantees the<br>existence and uniqueness of the root, the convergence of the Broyden’s method is also guaranteed,<br>which is typically faster than a linear rate.</p>
<p>其中B是Jacobian逆1的低阶近似，而α是我们使用线搜索方法动态计算的步长。 停止标准为kF（z [i]，x;θ）k 2 &lt;？  f，在哪里？  f是在计算时间和精度之间取得平衡的超参数。 由于定理1保证了根的存在和唯一性，因此也保证了Broyden方法的收敛性，通常比线性速率快。</p>
<p>Another inference problem is to estimate the log-likelihood. Assume that z ∼ p(z) where p(z) is a<br>simple prior distribution (e.g. standard Gaussian). The log-likelihood of x can be written by</p>
<p>另一个推断问题是估计对数似然性。 假设z〜p（z），其中p（z）是一个简单的先验分布（例如标准高斯分布）。  x的对数似然可以写成</p>
<p>where J f (x) denotes the Jacobian matrix of a function f at x. See Appendix. A.4 for the detailed<br>derivation. Exact calculation of the log-determinant term requires O(d 3 ) time cost and is hard to<br>scale up to high-dimensional data. Instead, we propose the following unbiased estimator of lnp(x)<br>using the same technique in Chen et al. (2019) with Skilling-Hutchinson trace estimator (Skilling,<br>1989; Hutchinson, 1989):</p>
<p>其中J f（x）表示x处函数f的雅可比矩阵。 见附录。  A.4为详细推导。 对数行列式项的精确计算需要O（d 3）时间成本，并且很难扩展到高维数据。 相反，我们使用Chen等人的相同技术提出了lnp（x）的以下无偏估计量。  （2019）和Skilling-Hutchinson追踪估算器（Skilling，1989; Hutchinson，1989）：</p>
<p>where p(N) is a distribution supported over the positive integers.</p>
<p>其中p（N）是在正整数上支持的分布。</p>
<p>The sampling process to compute x given z can also be solved by the Broyden’s method, and the<br>hyperparameters are shared with the inference process.</p>
<p>   计算给定z的x的采样过程也可以通过Broyden方法解决，并且超参数与推理过程共享。</p>
<p>In the learning process, we perform stochastic gradient descent to minimize the negative log-<br>likelihood of the data, denoted as L. For efficiency, we estimate the gradient w.r.t. the model<br>parameters in the backpropagation manner. According to the chain rule and the additivity of the<br>log-determinant, in each layer we need to estimate the gradients w.r.t. x and θ of Eqn. (13). In<br>particular, the gradients computation involves two terms: one is<br>∂<br>∂(·)<br>lndet(I + J g (x;θ)) and the other is<br>∂L<br>∂z<br>∂z<br>∂(·) , where g is a function satisfying Lip(g) &lt; 1 and (·) denotes x or θ. On the one<br>hand, for the log-determinant term, we can use the same technique as Chen et al. (2019), and obtain<br>an unbiased gradient estimator as follows.<br>   在学习过程中，我们执行随机梯度下降以最小化数据的负对数似然性（表示为L）。为了提高效率，我们估计了梯度w.r.t。 模型参数采用反向传播方式。 根据链式规则和对数行列式的可加性，在每一层中，我们需要估计梯度w.r.t。 等式的x和θ。  （13）。 特别地，梯度计算涉及两个术语：一个是∂（·）lndet（I + J g（x;θ）），而另一个是 other是∂L∂z∂z∂（·），其中g是满足Lip（g）&lt;1的函数，而（·）表示x或θ。 一方面，对于对数行列式，我们可以使用与Chen等人相同的技术。  （2019），并获得如下的无偏梯度估计量。</p>
<p>where p(N) is a distribution supported over the positive integers. On the other hand,<br>∂L<br>∂z<br>∂z<br>∂(·)<br>can be<br>computed according to the implicit function theorem as follows (See details in Appendix A.5):</p>
<p>其中p（N）是在正整数上支持的分布。 另一方面，可以根据隐函数定理如下计算computedL∂z∂z∂（·）（请参阅附录A.5中的详细信息）：</p>
<p>In comparision to directly calculate the gradient through the quasi-Newton iterations of the forward<br>pass, the implicit gradient above is simple and memory-efficient, treating the root solvers as a black-<br>box. Following Bai et al. (2019), we compute<br>∂L<br>∂z J<br>−1<br>G<br>(z) by solving a linear system iteratively, as<br>detailed in Appendix C.1. The training algorithm is formally presented in Appendix C.4.</p>
<p>为了通过前向传递的拟牛顿迭代直接计算梯度，上面的隐式梯度简单且存储效率高，将根求解器视为黑盒。 继Bai等。  （2019年），我们通过迭代求解线性系统来计算∂L∂zJ -1 G（z），如附录C.1所述。 训练算法在附录C.4中正式提出。</p>
<h2 id="A-Additional-Lemmas-And-Proofs"><a href="#A-Additional-Lemmas-And-Proofs" class="headerlink" title="A. Additional Lemmas And Proofs"></a>A. Additional Lemmas And Proofs<span id ="appa"></span></h2><p>引理和证明</p>
<h3 id="A-1-Proof-For-Theorem-1"><a href="#A-1-Proof-For-Theorem-1" class="headerlink" title="A.1 Proof For Theorem 1"></a>A.1 Proof For <a href="#the1">Theorem 1</a><span id ="app1"></span></h3><p>Proof. <a href="#the1">Theorem 1</a></p>
<p>首先，对任意的 $ \forall \mathbf{x}_{0} \in \mathbb{R}^{d} $，映射</p>
<script type="math/tex; mode=display">
\begin{equation}
 h_{\mathbf{x}_{0}}(\mathbf{z})=F\left(\mathbf{z}, \mathbf{x}_{0}\right)+\mathbf{z} 
\end{equation}</script><p>是一个对映(contrative)映射，可以通过 $g_{z}$ 的 Lipschitz 条件表示：</p>
<script type="math/tex; mode=display">
\begin{equation}
 \left(F\left(\mathbf{z}_{1}, \mathbf{x}_{0}\right)+\mathbf{z}_{1}\right)-\left(F\left(\mathbf{z}_{2}, \mathbf{x}_{0}\right)+\mathbf{z}_{2}\right)\|=\| g_{z}\left(\mathbf{z}_{1}\right)-g_{z}\left(\mathbf{z}_{2}\right)\|<\| \mathbf{z}_{1}-\mathbf{z}_{2} \mid 
\end{equation}</script><p>因此，$ h_{\mathbf{x}_{0}}(\mathbf{z}) $ 有一个唯一的不动点，用 $ f\left(\mathbf{x}_{0}\right) $ 表示：</p>
<script type="math/tex; mode=display">
\begin{equation}
 h_{\mathbf{x}_{0}}\left(f\left(\mathbf{x}_{0}\right)\right)=f\left(\mathbf{x}_{0}\right) \Leftrightarrow F\left(f\left(\mathbf{x}_{0}\right), \mathbf{x}_{0}\right)=0 
\end{equation}</script><p>类似地，我们还有：$ \forall \mathbf{z}_{0} \in \mathbb{R}^{d} $，存在一个满足 $ F\left(\mathbf{z}_{0}, g\left(\mathbf{z}_{0}\right)\right)=0 $ 的唯一 $ g\left(\mathbf{z}_{0}\right) $。</p>
<p>此外，令 $ \mathbf{z}_{0}=f\left(\mathbf{x}_{0}\right) $，我们有 $ F\left(f\left(\mathbf{x}_{0}\right), g\left(f\left(\mathbf{x}_{0}\right)\right)\right)=0 $。通过唯一性，我们有 $ g\left(f\left(\mathbf{x}_{0}\right)\right)=\mathbf{x}_{0} $，$\forall \mathbf{x}_{0} \in \mathbb{R}^{d}$。 同样，$ f\left(g\left(\mathbf{x}_{0}\right)\right)=\mathbf{x}_{0} $，$ \forall \mathbf{x}_{0} \in \mathbb{R}$。 因此，$f$ 是唯一且可逆的。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B. "></a>B. <span id ="appb"></span></h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/03/28/C-DL-W5/" rel="next" title="C_DL_W5">
                <i class="fa fa-chevron-left"></i> C_DL_W5
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/03/28/G-iResNet/" rel="prev" title="G_iResNet">
                G_iResNet <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Implicit-Normalizing-Flows"><span class="nav-number">1.</span> <span class="nav-text">Implicit Normalizing Flows</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Abstract"><span class="nav-number">1.1.</span> <span class="nav-text">Abstract</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Introduction"><span class="nav-number">1.2.</span> <span class="nav-text">1. Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Related-Work"><span class="nav-number">1.3.</span> <span class="nav-text">2. Related Work</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Expressive-Normalizing-Flows"><span class="nav-number">1.3.1.</span> <span class="nav-text">2.1. Expressive Normalizing Flows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Continuous-Time-Flows-CTFs"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.2. Continuous Time Flows (CTFs)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Implicit-Deep-Learning"><span class="nav-number">1.3.3.</span> <span class="nav-text">2.3. Implicit Deep Learning</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Implicit-Normalizing-Flows"><span class="nav-number">1.4.</span> <span class="nav-text">3. Implicit Normalizing Flows</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Normalizing-Flows"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.1. Normalizing Flows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Model-Specification"><span class="nav-number">1.4.2.</span> <span class="nav-text">3.2. Model Specification</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Definition-1"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Definition 1.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theorem-1"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">Theorem 1. </span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Expressiveness-Power"><span class="nav-number">1.5.</span> <span class="nav-text">4. Expressiveness Power</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Lipschitz-Continuous-Functions"><span class="nav-number">1.5.1.</span> <span class="nav-text">4.1. Lipschitz Continuous Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Definition-2"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Definition 2.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Definition-3"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">Definition 3.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Proposition-1"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">Proposition 1.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Comparision-to-Two-Block-ResFlows"><span class="nav-number">1.5.2.</span> <span class="nav-text">4.2. Comparision to Two-Block ResFlows</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lemma-1"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">Lemma 1.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theorem-2"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">Theorem 2.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Corollary-1"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">Corollary 1.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Comparison-with-Multi-Block-ResFlows"><span class="nav-number">1.5.3.</span> <span class="nav-text">4.3. Comparison with Multi-Block ResFlows</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Theorem-3"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">Theorem 3.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Generative-Modeling-With-ImpFlows"><span class="nav-number">1.6.</span> <span class="nav-text">5. Generative Modeling With ImpFlows</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A-Additional-Lemmas-And-Proofs"><span class="nav-number">1.7.</span> <span class="nav-text">A. Additional Lemmas And Proofs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-1-Proof-For-Theorem-1"><span class="nav-number">1.7.1.</span> <span class="nav-text">A.1 Proof For Theorem 1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B"><span class="nav-number">1.8.</span> <span class="nav-text">B. </span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      


      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Duan Yaqi</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>


<div class="powered-by">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <i class="fa fa-user-md"></i>
    <span id="busuanzi_container_site_uv">
        本站访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_pv">    
        本站访问量<span id="busuanzi_value_site_pv"></span>
    </span>
</div>





        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
